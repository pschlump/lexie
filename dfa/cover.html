
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">_/../../../../../Users/corwin/Projects/pongo2/lexie/dfa/dfa.go (81.3%)</option>
				
				<option value="file1">_/../../../../../Users/corwin/Projects/pongo2/lexie/dfa/match.go (81.1%)</option>
				
				<option value="file2">_/../../../../../Users/corwin/Projects/pongo2/lexie/dfa/nm.go (86.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >//
// D F A - Part of Lexie Lexical Generation System
//
// (C) Philip Schlump, 2014-2015.
// Version: 1.0.8
// BuildNo: 203
//
// Special Thanks to 2C-Why, LLC for supporting this project.
//

// -----------------------------------------------------------------------------------------------------------------------------------------------
/*
        1. Get .Tau set and reported in table-state machine
        2. Fix the new matcher
*/
// -----------------------------------------------------------------------------------------------------------------------------------------------

// -----------------------------------------------------------------------------------------------------------------------------------------------
//
// DFA - Deterministic Finite Automata.
//
// -----------------------------------------------------------------------------------------------------------------------------------------------
//
// Known Issues:
//
// -----------------------------------------------------------------------------------------------------------------------------------------------

package dfa

import (
        "fmt"
        "io"
        "os"
        "unicode"
        "unicode/utf8"

        "../com"
        "../nfa"
        "../re"
        "../smap"
        "../tok"

        "../../../go-lib/sizlib"
)

type DFA_Type struct {
        Next2      []nfa.TransitionType //
        Rv         int                  // 0 indicates not assigned, non-terminal
        Is0Ch      bool                 //        Tau
        Info       nfa.InfoType         //
        TRuleMatch int                  // may be a non-terminal that you want to know matched. -- A set of these is returned on matches or can be retrieved on fails too.
        NextFree   int                  //                For free list
        IsUsed     bool                 //                For Free list
        A_IAm      int                  //                Debug Usage
        LineNo     string               // LineNo where added
        StateName  string               // Used in NFA -&gt; DFA
        StateSet   []int                //
        Visited    bool                 //
}

type DFA_PoolType struct {
        Pool      []DFA_Type     //
        Cur       int            //
        Top       int            //
        NextFree  int            //
        InitState int            //
        Sigma     string         //
        MTab      *dfaTable      //
        TokList   *tok.TokenList // ATokBuffer TokenBuffer // Output Token Stuff
        MachineId int
}

const InitDFASize = 3

// -----------------------------------------------------------------------------------------------------------------------------------------------
// Create a new DFA pool
func NewDFA_Pool() *DFA_PoolType <span class="cov8" title="1">{
        return &amp;DFA_PoolType{
                Pool:     make([]DFA_Type, InitDFASize, InitDFASize),
                Cur:      0,
                Top:      InitDFASize,
                NextFree: -1,
        }
}</span>

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) DumpTokenBuffer() <span class="cov0" title="0">{
        dfa.TokList.DumpTokenBuffer()
}</span>

// -----------------------------------------------------------------------------------------------------------------------------------------------
// Allocate an DFA tree node
func (dfa *DFA_PoolType) GetDFA() int <span class="cov8" title="1">{
        //fmt.Printf("at %s\n", com.LF())
        tmp := 0
        if dfa.Cur &lt; dfa.Top &amp;&amp; !dfa.Pool[dfa.Cur].IsUsed </span><span class="cov8" title="1">{
                //fmt.Printf("at %s\n", com.LF())
                tmp = dfa.Cur
                dfa.Cur++
        }</span><span class="cov8" title="1"> else if dfa.Cur &gt;= dfa.Top || dfa.NextFree == -1 </span><span class="cov8" title="1">{
                //fmt.Printf("at %s, dfa.Cur=%d dfa.Top=%d dfa.NextFree=%d\n", com.LF(), dfa.Cur, dfa.Top, dfa.NextFree)
                dfa.Top = 2 * dfa.Top
                newPool := make([]DFA_Type, dfa.Top, dfa.Top) // extend array
                copy(newPool, dfa.Pool)
                dfa.Pool = newPool
                tmp = dfa.Cur
                dfa.Cur++
        }</span><span class="cov0" title="0"> else {
                //fmt.Printf("at %s\n", com.LF())
                tmp = dfa.NextFree
                dfa.NextFree = dfa.Pool[tmp].NextFree
        }</span>
        <span class="cov8" title="1">dfa.Pool[tmp].NextFree = -1
        dfa.Pool[tmp].Rv = 0
        dfa.Pool[tmp].Next2 = dfa.Pool[tmp].Next2[:0]
        dfa.Pool[tmp].IsUsed = true
        dfa.Pool[tmp].A_IAm = tmp
        dfa.Pool[tmp].LineNo = com.LINE(2)
        return tmp</span>
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
// Free an DFA tree node
func (dfa *DFA_PoolType) FreeDFA(ii int) <span class="cov0" title="0">{
        dfa.Pool[ii].IsUsed = false
        dfa.Pool[ii].NextFree = dfa.NextFree
        dfa.Pool[ii].Rv = 0
        dfa.Pool[ii].Next2 = dfa.Pool[ii].Next2[:0]
        dfa.NextFree = ii
}</span>

// -----------------------------------------------------------------------------------------------------------------------------------------------
// Return the start state number
func (dfa *DFA_PoolType) Pos0Start() int <span class="cov0" title="0">{
        return dfa.InitState
}</span>

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) DiscardPool() <span class="cov0" title="0">{
        dfa.Pool = make([]DFA_Type, InitDFASize, InitDFASize)
        dfa.Cur = 0
        dfa.Top = InitDFASize
        dfa.NextFree = -1
}</span>

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
//                 3. Input Parsing Issues/Errors/Warnings
//                                1. Can not have A_Pop and A_Push at same time - Check for this.
//                                2. A_Pop must be a hard match -
//                                3. A_Pop must be a terminal! - Return() must have a Rv()
//                                4. A_Push, A_Pop, A_Reset can not be ambiguous tokens, can not {% POP and {%= Return a value, won't work ( At least not yet )
func (dfa *DFA_PoolType) VerifyMachine() <span class="cov8" title="1">{
        for ii, vv := range dfa.Pool </span><span class="cov8" title="1">{
                if vv.IsUsed </span><span class="cov8" title="1">{
                        if vv.Info.Action != 0 </span><span class="cov8" title="1">{
                                if (vv.Info.Action&amp;com.A_Pop) != 0 &amp;&amp; (vv.Info.Action&amp;com.A_Push) != 0 </span><span class="cov0" title="0">{
                                        com.StashError(fmt.Sprintf("Error: State[%d] has both a Push/Call and a Pop/Return optration at the same time.\n", ii))
                                }</span>
                                <span class="cov8" title="1">if (vv.Info.Action&amp;com.A_Pop) != 0 &amp;&amp; (vv.Info.Action&amp;com.A_Reset) != 0 </span><span class="cov0" title="0">{
                                        com.StashError(fmt.Sprintf("Error: State[%d] has both a Push/Call and a Pop/Return optration at the same time.\n", ii))
                                }</span>
                                <span class="cov8" title="1">if (vv.Info.Action&amp;com.A_Push) != 0 &amp;&amp; (vv.Info.Action&amp;com.A_Reset) != 0 </span><span class="cov0" title="0">{
                                        com.StashError(fmt.Sprintf("Error: State[%d] has both a Push/Call and a Pop/Return optration at the same time.\n", ii))
                                }</span>
                                <span class="cov8" title="1">if ((vv.Info.Action&amp;com.A_Pop) != 0 || (vv.Info.Action&amp;com.A_Push) != 0 || (vv.Info.Action&amp;com.A_Reset) != 0) &amp;&amp; vv.Rv == 0 </span><span class="cov8" title="1">{
                                        com.StashError(fmt.Sprintf("Error: State[%d] a Push/Call or a Pop/Return/Reset optration Must be a terminal state with a Rv()\n", ii))
                                }</span>
                                <span class="cov8" title="1">if ((vv.Info.Action&amp;com.A_Pop) != 0 || (vv.Info.Action&amp;com.A_Push) != 0 || (vv.Info.Action&amp;com.A_Reset) != 0) &amp;&amp; !vv.Info.HardMatch </span><span class="cov8" title="1">{ // xyzzy8
                                        com.StashError(fmt.Sprintf("Info: State[%d] a Push/Call or a Pop/Return/Reset optration Must be a terminal state with fixed string matched, 'a*' or 'a?' is not a legitimate match.\n", ii))
                                }</span>

                        }
                }
        }
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
/*
type InfoType struct {
        Action      int
        MatchLength int
}

func (lex *Lexie) ConvertMachineNameToText(ee int) string {
        return lex.UseData.LexieData.MatchNames[ee]
}
*/

//func DumpInfo(info InfoType) string {
//        // xyzzy22 - convert info.NextState - &gt; state name
//        sa := ConvertActionFlagToString(info.Action)
//        // nsname := lex.ConvertMachineNameToText(info.NextState)
//        return fmt.Sprintf("Action: %s(%02x), Ns:%d, MatchLength:%d\n", sa, info.Action, info.NextState, info.MatchLength)
//}

func (dfa *DFA_PoolType) DumpPool(all bool) <span class="cov8" title="1">{
        if all </span><span class="cov0" title="0">{
                com.DbPrintf("db_DumpDFAPool", "Cur: %d Top: %d NextFree %d\n", dfa.Cur, dfa.Top, dfa.NextFree)
        }</span>
        <span class="cov8" title="1">com.DbPrintf("db_DumpDFAPool", "\n---------------------------- DFA Output -----------------------------------------------\n")
        com.DbPrintf("db_DumpDFAPool", "\nDFA InitState: %d, Sigma -&gt;%s&lt;-\n\n", dfa.InitState, dfa.Sigma)
        pLnNo := com.DbOn("db_DFA_LnNo")
        IfLnNo := func(s string) string </span><span class="cov8" title="1">{
                if pLnNo </span><span class="cov0" title="0">{
                        t := fmt.Sprintf("[%3s]", s)
                        return t
                }</span>
                <span class="cov8" title="1">return ""</span>
        }
        <span class="cov8" title="1">com.DbPrintf("db_DumpDFAPool", "%3s%s: ", "St", IfLnNo("/Ln"))
        com.DbPrintf("db_DumpDFAPool", " %12s %12s \u2714              \tEdges", "StateName", "StateSet")
        com.DbPrintf("db_DumpDFAPool", "\n\n")
        for ii, vv := range dfa.Pool </span><span class="cov8" title="1">{
                if all || vv.IsUsed </span><span class="cov8" title="1">{
                        com.DbPrintf("db_DumpDFAPool", "%3d%s: ", ii, IfLnNo(vv.LineNo))
                        com.DbPrintf("db_DumpDFAPool", " %12s %12s %s :", vv.StateName, sizlib.SVar(vv.StateSet), com.ChkOrBlank(vv.Visited))
                        if vv.Rv &gt; 0 </span><span class="cov8" title="1">{
                                if vv.Is0Ch </span><span class="cov8" title="1">{
                                        com.DbPrintf("db_DumpDFAPool", " \u03c4:Tau:%04d ", vv.Rv)
                                }</span><span class="cov8" title="1"> else {
                                        com.DbPrintf("db_DumpDFAPool", " T:%04d ", vv.Rv)
                                }</span>
                        }<span class="cov8" title="1"> else {
                                com.DbPrintf("db_DumpDFAPool", "        ")
                        }</span>
                        <span class="cov8" title="1">if com.DbOn("db_DumpDFAPool") </span><span class="cov8" title="1">{
                                fmt.Printf("\t E:")
                                for _, ww := range vv.Next2 </span><span class="cov8" title="1">{
                                        if ww.Is0ChMatch </span><span class="cov0" title="0">{
                                                fmt.Printf("//Found  \u03c4 (%s) //", com.LF()) // Show a Tau(t) for a lambda that matchiens on else conditions.
                                        }</span>
                                        <span class="cov8" title="1">if ww.IsLambda </span><span class="cov0" title="0">{
                                                fmt.Printf("{  ERROR!! \u03bb  %2d -&gt; %2d  %s}  ", ww.From, ww.To, ww.LineNo)
                                        }</span><span class="cov8" title="1"> else {
                                                // fmt.Printf("{ \"%s\" %2d -&gt; %2d  %s}  ", ww.On, ww.From, ww.To, IfLnNo(ww.LineNo))
                                                on, _ := utf8.DecodeRune([]byte(ww.On))
                                                son := fmt.Sprintf("%q", ww.On)
                                                switch on </span>{
                                                <span class="cov8" title="1">case re.R_DOT: // = '\uF8FA' // Any char in Sigma
                                                        son = "DOT/uF8FA"</span>
                                                <span class="cov0" title="0">case re.R_BOL: // = '\uF8F3' // Beginning of line
                                                        son = "BOL/uF8F3"</span>
                                                <span class="cov0" title="0">case re.R_EOL: // = '\uF8F4' // End of line
                                                        son = "EOL/uF8F4"</span>
                                                <span class="cov8" title="1">case re.R_NUMERIC: // = '\uF8F5'
                                                        son = "NUMERIC/uF8F5"</span>
                                                <span class="cov8" title="1">case re.R_LOWER: // = '\uF8F6'
                                                        son = "LOWER/uF8F6"</span>
                                                <span class="cov8" title="1">case re.R_UPPER: // = '\uF8F7'
                                                        son = "UPPER/uF8F7"</span>
                                                <span class="cov0" title="0">case re.R_ALPHA: // = '\uF8F8'
                                                        son = "ALPHA/uF8F8"</span>
                                                <span class="cov0" title="0">case re.R_ALPHNUM: // = '\uF8F9'
                                                        son = "ALPHANUM/uF8F9"</span>
                                                <span class="cov8" title="1">case re.R_EOF: // = '\uF8FB'
                                                        son = "EOF/uF8FB"</span>
                                                <span class="cov0" title="0">case re.R_not_CH: // = '\uF8FC' // On input lookup if the char is NOT in Signa then it is returned as this.
                                                        son = "else_CH/uF8Fc"</span>
                                                <span class="cov0" title="0">case re.R_N_CCL: // = '\uF8FD' // If char is not matched in this state then take this path
                                                        son = "N_CCL/uF8Fd"</span>
                                                <span class="cov0" title="0">case re.R_LAMBDA_MATCH: // = '\uF8FE'
                                                        son = "LambdaM/uF8FE"</span>
                                                }
                                                <span class="cov8" title="1">fmt.Printf("{ %s  %2d -&gt; %2d  %s}  ", son, ww.From, ww.To, IfLnNo(ww.LineNo))</span>
                                        }
                                }
                                <span class="cov8" title="1">fmt.Printf("\n")
                                if vv.Info.Action != 0 || vv.Info.MatchLength != 0 </span><span class="cov8" title="1">{
                                        // fmt.Printf("\t\t\tInfo: %s\n", sizlib.SVar(vv.Info))                // xyzzy - output Info
                                        // xyzzy - NextState info
                                        fmt.Printf("\t\t\tDFA.Info: %s", nfa.DumpInfo(vv.Info))
                                        // if ((vv.Info.Action&amp;com.A_Pop) != 0 || (vv.Info.Action&amp;com.A_Push) != 0 || (vv.Info.Action&amp;com.A_Reset) != 0) &amp;&amp; !vv.Info.HardMatch {                // xyzzy8
                                        fmt.Printf(" IsHard=%v (((false imples else case Rv!)))\n", vv.Info.HardMatch)
                                }</span>
                                <span class="cov8" title="1">fmt.Printf("\n")</span>
                        }
                }
        }
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) DumpPoolOneState(ii int) string <span class="cov0" title="0">{
        pLnNo := com.DbOn("db_DFA_LnNo")
        IfLnNo := func(s string) string </span><span class="cov0" title="0">{
                if pLnNo </span><span class="cov0" title="0">{
                        t := fmt.Sprintf("[%3s]", s)
                        return t
                }</span>
                <span class="cov0" title="0">return ""</span>
        }
        <span class="cov0" title="0">vv := dfa.Pool[ii]
        s := ""
        s += fmt.Sprintf("%3d%s: ", ii, IfLnNo(vv.LineNo))
        s += fmt.Sprintf(" %12s %12s %s :", vv.StateName, sizlib.SVar(vv.StateSet), com.ChkOrBlank(vv.Visited))
        if vv.Rv &gt; 0 </span><span class="cov0" title="0">{
                s += fmt.Sprintf(" T:%04d ", vv.Rv)
        }</span><span class="cov0" title="0"> else {
                s += fmt.Sprintf("        ")
        }</span>
        <span class="cov0" title="0">s += fmt.Sprintf("\t E:")
        for _, ww := range vv.Next2 </span><span class="cov0" title="0">{
                if ww.IsLambda </span><span class="cov0" title="0">{
                        s += fmt.Sprintf("{  ERROR!! \u03bb  %2d -&gt; %2d  %s}  ", ww.From, ww.To, ww.LineNo)
                }</span><span class="cov0" title="0"> else {
                        s += fmt.Sprintf("{ \"%s\" %2d -&gt; %2d  %s}  ", ww.On, ww.From, ww.To, IfLnNo(ww.LineNo))
                }</span>
        }
        <span class="cov0" title="0">s += "\n"
        if vv.Info.Action != 0 || vv.Info.MatchLength != 0 </span><span class="cov0" title="0">{
                s += fmt.Sprintf("\t\t\tDFA.Info: %s", nfa.DumpInfo(vv.Info))
        }</span>
        <span class="cov0" title="0">s += "\n"
        return s</span>
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) HaveStateAlready(inputSet []int) (loc int) <span class="cov8" title="1">{
        // fmt.Printf("HaveStateAlready: &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0 inputSet: %s\n", sizlib.SVar(inputSet))
        inputSet = com.USortIntSlice(inputSet) // Make set unique
        // fmt.Printf("HaveStateAlready: &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1 inputSet: %s\n", sizlib.SVar(inputSet))
        s := com.NameOf(inputSet)
        // fmt.Printf("HaveStateAlready: &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Name searcing for is: %s\n", s)
        for ii, vv := range dfa.Pool </span><span class="cov8" title="1">{
                //                if ii &gt;= dfa.Cur || ii &gt;= dfa.Top {
                //                        fmt.Printf("   Reached break\n")
                //                        break
                //                }
                if vv.IsUsed </span><span class="cov8" title="1">{
                        // fmt.Printf(" ****** Checking for match between dfa.Pool[%d].StateName -&gt;%s&lt;- and -&gt;%s&lt;-\n", ii, vv.StateName, s)
                        if vv.StateName == s </span><span class="cov8" title="1">{
                                // fmt.Printf("   Match found at %d\n", ii)
                                return ii
                        }</span>
                }
        }
        // fmt.Printf("    no Match found, returing -1\n")
        <span class="cov8" title="1">return -1</span>
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) NoneVisited() <span class="cov8" title="1">{
        for ii, vv := range dfa.Pool </span><span class="cov8" title="1">{
                if vv.IsUsed </span><span class="cov0" title="0">{
                        dfa.Pool[ii].Visited = false
                }</span>
        }
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) FindNotVisited() int <span class="cov8" title="1">{
        for ii, vv := range dfa.Pool </span><span class="cov8" title="1">{
                if vv.IsUsed &amp;&amp; !vv.Visited </span><span class="cov8" title="1">{
                        return ii
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) GetDFAName(StateSet []int) int <span class="cov8" title="1">{
        A := dfa.GetDFA()
        StateSet = com.USortIntSlice(StateSet) // Make set unique
        dfa.Pool[A].StateSet = StateSet
        dfa.Pool[A].StateName = com.NameOf(StateSet)
        dfa.Pool[A].Visited = false
        return A
}</span>

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) AddEdge(fr, to int, on string) <span class="cov8" title="1">{
        // Check if edge already exists - if so skip this
        if !dfa.EdgeExists(fr, to, on) </span><span class="cov8" title="1">{
                dfa.Pool[fr].Next2 = append(dfa.Pool[fr].Next2, nfa.TransitionType{IsLambda: false, On: on, To: to, From: fr, LineNo: com.LINE(2)})
        }</span>
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) EdgeExists(fr, to int, on string) bool <span class="cov8" title="1">{
        //        for _, vv := range dfa.Pool[fr].Next2 {
        //                if vv.To == to &amp;&amp; vv.On == on {
        //                        return true
        //                }
        //        }
        return false
}</span>

// -----------------------------------------------------------------------------------------------------------------------------------------------
//
// func RunDFA ( ) - Run the DFA on some input and report back the set of tokens
// Tokens must contain - Start Line No, Col No, File Name, End*, Macro Translation(pushback)
//
// Note: http://www.w3schools.com/charsets/ref_utf_dingbats.asp
//       http://www.utf8-chartable.de/unicode-utf8-table.pl?start=768
//

func (dfa *DFA_PoolType) ConvNDA_to_DFA(nn *nfa.NFA_PoolType) <span class="cov8" title="1">{
        StartState := nn.InitState
        dfa.NoneVisited()

        nn.Sigma = nn.GenerateSigma()
        dfa.Sigma = nn.Sigma
        com.DbPrintf("dfa2", "Sigma at top -&gt;%s&lt;-\n", dfa.Sigma)

        // Build initial state
        dfa_set := nn.LambdaClosure([]int{StartState}) // Find all the lambda closures from specified state
        dfa_set = append(dfa_set, StartState)          // Add in initial state
        dfa_set = com.USortIntSlice(dfa_set)           // Make set unique
        com.DbPrintf("db_DFAGen", "\nStart: %s, \u03a3 =-&gt;%s&lt;-, %s\n", sizlib.SVar(dfa_set), dfa.Sigma, com.LF())
        A := dfa.GetDFAName(dfa_set)
        if r, is, info, Is0Ch := nn.IsTerminalState(dfa_set); is </span><span class="cov8" title="1">{
                dfa.Pool[A].Rv = r
                dfa.Pool[A].Is0Ch = Is0Ch
                dfa.Pool[A].Info = info
        }</span><span class="cov8" title="1"> else {
                dfa.Pool[A].Info = info
        }</span>
        <span class="cov8" title="1">if com.DbOn("db_DFAGen") </span><span class="cov0" title="0">{
                dfa.DumpPool(false)
        }</span>
        // Look at all the locaitons we can get to from this "state"
        <span class="cov8" title="1">for _, S := range dfa.Sigma </span><span class="cov8" title="1">{
                StateSet := nn.LambdaClosureSet(dfa_set, string(S))
                com.DbPrintf("db_DFAGen", "FOR INITIAL state -&gt;%s&lt;- StateSet=%s, %s\n", string(S), sizlib.SVar(StateSet), com.LF())
                if len(StateSet) &gt; 0 </span><span class="cov8" title="1">{
                        com.DbPrintf("db_DFAGen", "Have a non-empty result, %s\n", com.LF())
                        com.DbPrintf("db_DFAGen", "&lt;&gt;&lt;&gt;&lt;&gt; this is the point where we should check to see if 'S' is DOT or NCCL, %s\n", com.LF())

                        StateSetT := nn.LambdaClosure(StateSet) // need to lambda complete the state set
                        StateSet = append(StateSet, StateSetT...)
                        StateSet = com.USortIntSlice(StateSet) // Make set unique
                        com.DbPrintf("db_DFAGen", "    Output Is %s, %s\n", sizlib.SVar(StateSet), com.LF())
                        B := 0
                        if t := dfa.HaveStateAlready(StateSet); t != -1 </span><span class="cov8" title="1">{ // Have Already
                                B = t
                                com.DbPrintf("db_DFAGen", "    Already have this state at location %d, %s\n", t, com.LF())
                        }</span><span class="cov8" title="1"> else {
                                B = dfa.GetDFAName(StateSet)
                                com.DbPrintf("db_DFAGen", "    *** New state %d, %s\n", B, com.LF())
                        }</span>
                        <span class="cov8" title="1">dfa.AddEdge(A, B, string(S))
                        com.DbPrintf("db_DFAGen", "    *** Before (top) %s\n", com.LF())
                        if r, is, info, Is0Ch := nn.IsTerminalState(StateSet); is </span><span class="cov8" title="1">{
                                dfa.Pool[B].Rv = r
                                dfa.Pool[B].Is0Ch = Is0Ch
                                dfa.Pool[B].Info = info
                                com.DbPrintf("db_DFAGen", "    *** New state %d, %s\n", B, com.LF())
                        }</span><span class="cov8" title="1"> else if _, is, info, Is0Ch := nn.IsNonTerminalPushPopState(StateSet); is </span><span class="cov8" title="1">{
                                dfa.Pool[B].Is0Ch = Is0Ch
                                dfa.Pool[B].Info = info
                                com.DbPrintf("db_DFAGen", "    *** New info for state %d, %s\n", B, com.LF())
                        }</span><span class="cov8" title="1"> else {
                                dfa.Pool[B].Info = info
                                com.DbPrintf("db_DFAGen", "    *** NO State Info for state %d, %s\n", B, com.LF())
                        }</span>
                        <span class="cov8" title="1">com.DbPrintf("db_DFAGen", "    *** After (top) %s\n", com.LF())
                        if com.DbOn("db_DFAGen") </span><span class="cov0" title="0">{
                                fmt.Printf("for %s StateSet=%s, A=%d, B=%s %s\n", string(S), sizlib.SVar(StateSet), A, sizlib.SVar(B), com.LF())
                                dfa.DumpPool(false)
                        }</span>
                }
        }
        <span class="cov8" title="1">dfa.Pool[A].Visited = true

        com.DbPrintf("db_DFAGen", "\nBefore Main Loop, %s\n", com.LF())
        limit := 0
        for stateToDo := dfa.FindNotVisited(); stateToDo != -1; stateToDo = dfa.FindNotVisited() </span><span class="cov8" title="1">{
                com.DbPrintf("db_DFAGen", "\nMain Loop: !!TOP!! State:%d\n", stateToDo)
                // -----------------------------------------------------------------------------------------------------------
                if !dfa.Pool[stateToDo].Visited </span><span class="cov8" title="1">{
                        dfa_set := nn.LambdaClosure(dfa.Pool[stateToDo].StateSet)  // Find all the lambda closures from specified state
                        dfa_set = append(dfa_set, dfa.Pool[stateToDo].StateSet...) // Add in initial state
                        dfa_set = com.USortIntSlice(dfa_set)                       // Make set unique
                        for _, S := range dfa.Sigma </span><span class="cov8" title="1">{
                                StateSet := nn.LambdaClosureSet(dfa_set, string(S))
                                com.DbPrintf("db_DFAGen", "    for initial state %s StateSet=%s, %s\n", string(S), sizlib.SVar(StateSet), com.LF())
                                com.DbPrintf("db_DFAGen", "&lt;&gt;&lt;&gt;&lt;&gt; this is the point where we should check to see if 'S' is DOT or NCCL, %s\n", com.LF())
                                if len(StateSet) &gt; 0 </span><span class="cov8" title="1">{
                                        com.DbPrintf("db_DFAGen", "    &gt;&gt;&gt; Have a non-empty result, Input Is %s, %s\n", sizlib.SVar(StateSet), com.LF())
                                        StateSetT := nn.LambdaClosure(StateSet) // need to lambda complete the state set
                                        StateSet = append(StateSet, StateSetT...)
                                        StateSet = com.USortIntSlice(StateSet) // Make set unique
                                        com.DbPrintf("db_DFAGen", "    &gt;&gt;&gt; Output Is %s, %s\n", sizlib.SVar(StateSet), com.LF())
                                        B := 0
                                        if t := dfa.HaveStateAlready(StateSet); t != -1 </span><span class="cov8" title="1">{ // Have Already
                                                B = t
                                                com.DbPrintf("db_DFAGen", "    Already have this state at location %d, %s\n", t, com.LF())
                                        }</span><span class="cov8" title="1"> else {
                                                B = dfa.GetDFAName(StateSet)
                                        }</span>
                                        <span class="cov8" title="1">dfa.AddEdge(stateToDo, B, string(S))
                                        com.DbPrintf("db_DFAGen", "    *** Before %s\n", com.LF())
                                        if r, is, info, Is0Ch := nn.IsTerminalState(StateSet); is </span><span class="cov8" title="1">{
                                                dfa.Pool[B].Rv = r
                                                dfa.Pool[B].Is0Ch = Is0Ch
                                                dfa.Pool[B].Info = info
                                                com.DbPrintf("db_DFAGen", "    *** New state %d, %s\n", B, com.LF())
                                        }</span><span class="cov8" title="1"> else if _, is, info, Is0Ch := nn.IsNonTerminalPushPopState(StateSet); is </span><span class="cov8" title="1">{
                                                dfa.Pool[B].Is0Ch = Is0Ch
                                                dfa.Pool[B].Info = info
                                                com.DbPrintf("db_DFAGen", "    *** New info for state %d, %s\n", B, com.LF())
                                        }</span><span class="cov8" title="1"> else {
                                                com.DbPrintf("db_DFAGen", "    *** NO State Info for state %d, %s\n", B, com.LF())
                                                dfa.Pool[B].Info = info
                                        }</span>
                                        <span class="cov8" title="1">com.DbPrintf("db_DFAGen", "    *** After %s\n", com.LF())
                                        if com.DbOn("db_DFAGen") </span><span class="cov0" title="0">{
                                                fmt.Printf("    Add New Edge on %s fr %d to %d, %s\n", string(S), stateToDo, B, com.LF())
                                                fmt.Printf("    for %s StateSet=%s, A(stateToDo)=%d, %s\n", string(S), sizlib.SVar(StateSet), stateToDo, com.LF())
                                                dfa.DumpPool(false)
                                        }</span>
                                }
                        }
                }
                // -----------------------------------------------------------------------------------------------------------
                <span class="cov8" title="1">dfa.Pool[stateToDo].Visited = true
                limit++
                if limit &gt; 50000 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">dfa.VerifyMachine()</span>

}

// -----------------------------------------------------------------------------------------------------------------------------------------------
//

func (dfa *DFA_PoolType) DumpPoolJSON(fo io.Writer, td string, tn int) <span class="cov8" title="1">{
        fmt.Fprintf(fo, `{"Input":%q, "Rv":%d, "Start": %d, "States":[%s`, td, tn, dfa.InitState, "\n")
        for ii, vv := range dfa.Pool </span><span class="cov8" title="1">{
                if vv.IsUsed </span><span class="cov8" title="1">{
                        fmt.Fprintf(fo, ` { "Sn":%d, `, ii)
                        if vv.Rv &gt; 0 </span><span class="cov8" title="1">{
                                fmt.Fprintf(fo, ` "Term":%d, `, vv.Rv)
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintf(fo, ` "Edge":[ `)
                        com := ""
                        for _, ww := range vv.Next2 </span><span class="cov8" title="1">{
                                fmt.Fprintf(fo, "%s{ \"On\":\"%s\", \"Fr\":%d, \"To\":%d }", com, ww.On, ww.From, ww.To)
                                com = ", "
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintf(fo, "]}\n")</span>
                }
        }
        <span class="cov8" title="1">fmt.Fprintf(fo, "]}\n")</span>
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
//

func (dfa *DFA_PoolType) GenerateGVFile(fo io.Writer, td string, tn int) <span class="cov8" title="1">{
        // fmt.Fprintf(fo, `{"Input":%q, "Rv":%d, "Start": %d, "Sigma":%q, "States":[%s`, td, tn, dfa.InitState, dfa.Sigma, "\n")
        siz := "5"
        if len(dfa.Pool) &gt; 100 </span><span class="cov0" title="0">{
                siz = "50"
        }</span><span class="cov8" title="1"> else if len(dfa.Pool) &gt; 50 </span><span class="cov8" title="1">{
                siz = "40"
        }</span><span class="cov8" title="1"> else if len(dfa.Pool) &gt; 30 </span><span class="cov0" title="0">{
                siz = "55"
        }</span><span class="cov8" title="1"> else if len(dfa.Pool) &gt; 20 </span><span class="cov0" title="0">{
                siz = "10"
        }</span><span class="cov8" title="1"> else if len(dfa.Pool) &gt; 10 </span><span class="cov8" title="1">{
                siz = "8"
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(fo,
                `digraph finite_state_machine {
        rankdir=LR;
        size="18,%s"
`, siz)
        // size= for bigger graph - should be configurable with tests -

        var term []int
        for ii, vv := range dfa.Pool </span><span class="cov8" title="1">{
                if vv.IsUsed </span><span class="cov8" title="1">{
                        if vv.Rv &gt; 0 </span><span class="cov8" title="1">{
                                term = append(term, ii)
                        }</span>
                }
        }
        <span class="cov8" title="1">s := ""
        cc := ""
        for _, vv := range term </span><span class="cov8" title="1">{
                s += cc + fmt.Sprintf("s%d", vv)
                cc = " "
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(fo,
                `        node [shape = doublecircle]; %s;
        node [shape = circle];
`, s)

        for _, vv := range dfa.Pool </span><span class="cov8" title="1">{
                if vv.IsUsed </span><span class="cov8" title="1">{
                        for _, ww := range vv.Next2 </span><span class="cov8" title="1">{
                                if ww.On[0] &lt;= ' ' </span><span class="cov8" title="1">{
                                        fmt.Fprintf(fo, "        s%d -&gt; s%d [ label = %q ];\n", ww.From, ww.To, re.EscapeStrForGV(ww.On))
                                }</span><span class="cov8" title="1"> else {
                                        fmt.Fprintf(fo, "        s%d -&gt; s%d [ label = \"%s\" ];\n", ww.From, ww.To, re.EscapeStr(ww.On))
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">fmt.Fprintf(fo, "}\n")</span>
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------
// 1. Build the maping info InputMap0, Ranges, etc.                        1hr
// 2. Test this with current machines                                                1hr
// 3. Generate the array-based machine.                                                2hr
// 4. Hand verify - write an output function
// 5. Check this.                                                                                ++        4hr
//
// Let's build the map stuff as it's own little project, ./smap
//        fx:                minv, maxv, m0, m1 := smap.BuildMapString ( Sigma, NoMapRn )
//        fx:                k := smap.MapRune ( rn )
// ------------------------------------------------------------------------------------------------------------------------------------------------------

type MachineStatesType struct {
        Rv   int          //
        Tau  bool         //
        Info nfa.InfoType //
        To   []int        //
}

type dfaTable struct {
        InitState int                  //
        N_States  int                  //
        Width     int                  //
        SMap      *smap.SMapType       //
        Machine   []*MachineStatesType //
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) NumberOfStates() (N_States int) <span class="cov8" title="1">{
        N_States = 0
        for _, vv := range dfa.Pool </span><span class="cov8" title="1">{
                if vv.IsUsed </span><span class="cov8" title="1">{
                        N_States++
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) ConvertToTable() (rv dfaTable) <span class="cov8" title="1">{
        rv.InitState = dfa.InitState
        rv.SMap = smap.NewSMapType(dfa.Sigma, re.R_not_CH)
        rv.N_States = dfa.NumberOfStates()
        rv.Machine = make([]*MachineStatesType, rv.N_States, rv.N_States)
        XLen := rv.SMap.Length()
        rv.Width = XLen

        jj := 0
        for ii, vv := range dfa.Pool </span><span class="cov8" title="1">{
                if vv.IsUsed </span><span class="cov8" title="1">{
                        rv.Machine[jj] = &amp;MachineStatesType{Rv: vv.Rv, Info: vv.Info, Tau: vv.Is0Ch}
                        rv.Machine[jj].To = make([]int, XLen, XLen)
                        for kk := 0; kk &lt; XLen; kk++ </span><span class="cov8" title="1">{
                                rv.Machine[jj].To[kk] = -1
                        }</span>
                        <span class="cov8" title="1">dot := false
                        dotTo := 0
                        alpha := false
                        alphaTo := 0
                        num := false
                        numTo := 0
                        for _, ww := range vv.Next2 </span><span class="cov8" title="1">{
                                //if s == re.X_DOT {
                                // return "\u2022"        // Middle Bullet
                                if ww.On == re.X_DOT </span><span class="cov8" title="1">{
                                        // fmt.Printf("Found a dot, at jj=%d\n", jj)
                                        dot = true
                                        dotTo = ww.To
                                }</span><span class="cov8" title="1"> else if ww.On == re.X_ALPHA </span><span class="cov0" title="0">{
                                        // fmt.Printf("Found a alpha, at jj=%d\n", jj)
                                        alpha = true
                                        alphaTo = ww.To
                                        rr, _ := utf8.DecodeRune([]byte(ww.On))
                                        xx := rv.SMap.MapRune(rr)
                                        rv.Machine[jj].To[xx] = ww.To
                                }</span><span class="cov8" title="1"> else if ww.On == re.X_NUMERIC </span><span class="cov8" title="1">{
                                        // com.DbPrintf("dfa2", "Found a numeric, at jj=%d\n", jj)
                                        num = true
                                        numTo = ww.To
                                        rr, _ := utf8.DecodeRune([]byte(ww.On))
                                        xx := rv.SMap.MapRune(rr)
                                        rv.Machine[jj].To[xx] = ww.To
                                }</span><span class="cov8" title="1"> else {
                                        rr, _ := utf8.DecodeRune([]byte(ww.On))
                                        xx := rv.SMap.MapRune(rr)
                                        rv.Machine[jj].To[xx] = ww.To
                                }</span>
                        }
                        <span class="cov8" title="1">if num </span><span class="cov8" title="1">{
                                for ii := 0; ii &lt; rv.Width; ii++ </span><span class="cov8" title="1">{
                                        // rn := rune(ii + rv.SMap.MinV)
                                        rn := rv.SMap.SigmaRN[ii]
                                        // func (smap *SMapType) ReverseMapRune(x int) rune {
                                        // com.DbPrintf("dfa2", "numeric: -&gt;%s&lt;-\n", string(rn))
                                        if rv.Machine[jj].To[ii] == -1 &amp;&amp; unicode.IsDigit(rn) </span><span class="cov0" title="0">{
                                                rv.Machine[jj].To[ii] = numTo
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if alpha </span><span class="cov0" title="0">{
                                for ii := 0; ii &lt; rv.Width; ii++ </span><span class="cov0" title="0">{
                                        // rn := rune(ii + rv.SMap.MinV)
                                        rn := rv.SMap.SigmaRN[ii]
                                        if rv.Machine[jj].To[ii] == -1 &amp;&amp; (unicode.IsUpper(rn) || unicode.IsLower(rn)) </span><span class="cov0" title="0">{
                                                rv.Machine[jj].To[ii] = alphaTo
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if dot </span><span class="cov8" title="1">{
                                for ii := 0; ii &lt; rv.Width; ii++ </span><span class="cov8" title="1">{
                                        if rv.Machine[jj].To[ii] == -1 </span><span class="cov8" title="1">{
                                                rv.Machine[jj].To[ii] = dotTo
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if ((vv.Info.Action&amp;com.A_Pop) != 0 || (vv.Info.Action&amp;com.A_Push) != 0 || (vv.Info.Action&amp;com.A_Reset) != 0) &amp;&amp; !vv.Info.HardMatch </span><span class="cov8" title="1">{ // xyzzy8
                                com.DbPrintf("dfa7", "Info2-in-TabGen: State[%d] a Push/Call or a Pop/Return/Reset optration Must be a terminal state with fixed string matched, 'a*' or 'a?' is not a legitimate match.\n", ii)
                                //for ii := 0; ii &lt; rv.Width; ii++ {
                                //        if rv.Machine[jj].To[ii] == -1 {
                                //                rv.Machine[jj].To[ii] = dotTo
                                //        }
                                //}
                        }</span>
                        <span class="cov8" title="1">jj++</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) FinializeDFA() <span class="cov8" title="1">{

        dt := dfa.ConvertToTable()
        dfa.MTab = &amp;dt

}</span>

// -----------------------------------------------------------------------------------------------------------------------------------------------
func (dfa *DFA_PoolType) OutputInFormat(fo io.Writer, format string) <span class="cov8" title="1">{

        //        dfa.FinializeDFA()
        dt := dfa.MTab

        //dt := dfa.ConvertToTable()
        //dfa.MTab = &amp;dt

        if com.DbOn("output-machine") </span><span class="cov8" title="1">{

                if format == "text" </span><span class="cov8" title="1">{

                        fmt.Fprintf(fo, `
Sigma = %q
InitState = %d
N_States = %d
Width = %d
`, dfa.Sigma, dt.InitState, dt.N_States, dt.Width)

                        SigmaArray := make([]rune, dt.Width, dt.Width)
                        pp := 0
                        for jj := 0; jj &lt; dt.Width; jj++ </span><span class="cov8" title="1">{
                                if pp &lt; len(dfa.Sigma) </span><span class="cov8" title="1">{
                                        rn, sz := utf8.DecodeRune([]byte(dfa.Sigma[pp:]))
                                        SigmaArray[jj] = rn
                                        pp += sz
                                }</span><span class="cov8" title="1"> else {
                                        // SigmaArray[jj] = rune(0xFBAD)
                                        SigmaArray[jj] = dt.SMap.NoMap
                                }</span>
                        }

                        <span class="cov8" title="1">fmt.Fprintf(fo, "SMap = %+v\n", dt.SMap)
                        fmt.Fprintf(fo, "%-6s : %-4s  %-5s %-5s %-4s %-4s    | ", "State", "Rv", "Actn", "Hard", "Next", "Leng")
                        for jj := 0; jj &lt; dt.Width; jj++ </span><span class="cov8" title="1">{
                                fmt.Fprintf(fo, "   %2d", jj)
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintf(fo, "\n")
                        fmt.Fprintf(fo, "%-6s : %-4s  %-5s %-5s %-4s %-4s    | ", "======", "====", "-----", "-----", "----", "----")
                        for jj := 0; jj &lt; dt.Width; jj++ </span><span class="cov8" title="1">{
                                fmt.Fprintf(fo, "   %2s", "--")
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintf(fo, "\n")

                        fmt.Fprintf(fo, "%-6s : %-4s  %-5s %-5s %-4s %-4s    | ", " ", " ", " ", " ", " ", " ")
                        for jj := 0; jj &lt; dt.Width; jj++ </span><span class="cov8" title="1">{
                                if SigmaArray[jj] &lt; ' ' </span><span class="cov8" title="1">{
                                        s := fmt.Sprintf("%q", string(SigmaArray[jj]))
                                        s = s[1:]
                                        fmt.Fprintf(fo, "   %2s", s[0:len(s)-1])
                                }</span><span class="cov8" title="1"> else {
                                        fmt.Fprintf(fo, "   %2s", string(SigmaArray[jj]))
                                }</span>
                        }
                        <span class="cov8" title="1">fmt.Fprintf(fo, "\n")

                        fmt.Fprintf(fo, "%-6s : %-4s  %-5s %-5s %-4s %-4s    | ", "======", "====", "-----", "-----", "----", "----")
                        for jj := 0; jj &lt; dt.Width; jj++ </span><span class="cov8" title="1">{
                                fmt.Fprintf(fo, "   %2s", "--")
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintf(fo, "\n")
                        for ii, vv := range dt.Machine </span><span class="cov8" title="1">{
                                tau := " "
                                if vv.Tau </span><span class="cov8" title="1">{
                                        tau = "\u03c4"
                                }</span>
                                <span class="cov8" title="1">if vv.Info.Action == 0 </span><span class="cov8" title="1">{
                                        fmt.Fprintf(fo, "m[%3d] : %4d%s %5s %5v %4d %4d    | ", ii, vv.Rv, tau, "", vv.Info.HardMatch, vv.Info.NextState, vv.Info.MatchLength)
                                }</span><span class="cov8" title="1"> else {
                                        fmt.Fprintf(fo, "m[%3d] : %4d%s %5x %5v %4d %4d    | ", ii, vv.Rv, tau, vv.Info.Action, vv.Info.HardMatch, vv.Info.NextState, vv.Info.MatchLength)
                                }</span>
                                <span class="cov8" title="1">for _, ww := range vv.To </span><span class="cov8" title="1">{
                                        if ww == -1 </span><span class="cov8" title="1">{
                                                // fmt.Fprintf(fo, "   %2s", "\u26d4") // No Entry
                                                fmt.Fprintf(fo, "   %2s", "\u2629")
                                        }</span><span class="cov8" title="1"> else {
                                                fmt.Fprintf(fo, "   %2d", ww)
                                        }</span>
                                }
                                <span class="cov8" title="1">fmt.Fprintf(fo, "\n")</span>
                        }
                        <span class="cov8" title="1">fmt.Fprintf(fo, "\n")</span>

                }<span class="cov0" title="0"> else {
                        fmt.Fprintf(os.Stderr, "Invalid Output Format for dfa.OutputInFomrat, %s\n", format)
                }</span>
        }
}

/* vim: set noai ts=4 sw=4: */
</pre>
		
		<pre class="file" id="file1" style="display: none">//
// M A T C H - Part of Lexie Lexical Generation System
//
// (C) Philip Schlump, 2014-2015.
// Version: 1.0.8
// BuildNo: 203
//
// Special Thanks to 2C-Why, LLC for supporting this project.
//

/*
// ------------------------------------------------------------------------------------------------------------------------------------------------
// Plan
// ------------------------------------------------------------------------------------------------------------------------------------------------

+1. Study Django templates
        +2. Understand what they do
        +2. Decide on replace or use code
                http://www.b-list.org/weblog/2007/sep/22/standalone-django-scripts/

+0. What I want is to be able to get a lit of tokens/class/values out as an output from the CLI

+0. Use CLI and turn off all extraneous output -- Validate matches on a bunch of machines

0. Output machine as a .mlex format - machine lex format -m &lt;fn&gt;
0. Output machine as a .go format --fmt go -o &lt;fn&gt;
0. add "$cfg" to input - for config params like size of smap
0. add a SetConfig() to code to set the config params

+1. Use in Ringo
+2. The Pongo2 v.s. Ringo test
+3. Coverage Testing
4. Benchmarks
4. Memory usage - eliminate dynamic allocations
+4. Internal comments (doc.go) etc.
+5. As a "go-routine"



// ------------------------------------------------------------------------------------------------------------------------------------------------
//
// TODO:
//                1. Failure to match causes a fall-out-the-bottom and quit behavior - change to a reset to 0 and continue to EOF
//                                1. Warnings about bad tokens are not reported a {{ token should produce an error about invalid range.
//                                         1. xyzzyStackEmpty - if stack not empty then - pop and continue running on different data??a
//                1. In nfa-&gt;dfa conversion may end up with non-distinct terminal values - use one that is first seen? -- Lex implies this.
//                1. Rune Fix ( ../re/re.go:800 ) + test cases
//                                         xyzzyRune  TODO - this code is horribley non-utf8 compatable at this moment in time.
//
//        Err-Output:
//                        1. Tests in ../in/in.go - are not automated - fix to check results of input to be correct
//                                5. No test case for A_Reset
//                                7. No Test case for this error: --- CCL --- 0-0 is an invalid CCL, 1-0 also etc. -- Report
//
//        Feature
//                        1. Options on size of smap
//
// ------------------------------------------------------------------------------------------------------------------------------------------------
*/

package dfa

import (
        "fmt"
        "io"
        "os/exec"
        "sort"
        "strings"

        "../com"
        "../in"
        "../nfa"
        "../pbread"
        "../re"
        "../tok"
)

type LexieChanelType struct {
        Token tok.Token
}

type LexieStackType struct {
        St int // Current State in
}

type Lexie struct {
        IsCompiled bool // Is it currently compiled into a DFA
        NFA        []*nfa.NFA_PoolType
        DFA        []*DFA_PoolType
        Machines   []int

        NFA_Machine []*nfa.NFA_PoolType
        DFA_Machine []*DFA_PoolType

        TokList *tok.TokenList // ATokBuffer TokenBuffer // Output Token Stuff

        Im *in.ImType

        InputReader  *pbread.PBReadType
        StartMachine string

        // Channel to return data on
        SendOnChanel bool
        Message      chan LexieChanelType
}

// -----------------------------------------------------------------------------------------------------------------------------

// See: /Users/corwin/Projects/pongo2/lexie/note/t1.lex.go.old

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
func NewLexie() *Lexie <span class="cov8" title="1">{ // Create a new matcher pool
        return &amp;Lexie{
                IsCompiled:   false,
                SendOnChanel: false,
                Message:      make(chan LexieChanelType),
        }
}</span>

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
func (lex *Lexie) SetChanelOnOff(flag bool) <span class="cov0" title="0">{
        lex.SendOnChanel = flag
}</span>

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------

func ConvertStringActionToFlag(aa string) (rv int) <span class="cov0" title="0">{
        sa := strings.Split(aa, "|")
        rv = 0
        for _, tt := range sa </span><span class="cov0" title="0">{
                if x, ok := com.ReservedActionValues[tt]; ok </span><span class="cov0" title="0">{
                        rv |= x
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------

func KeyIntMapStringSort(in map[int]string) []int <span class="cov0" title="0">{
        var rv []int
        for ii, _ := range in </span><span class="cov0" title="0">{
                rv = append(rv, ii)
        }</span>
        <span class="cov0" title="0">return KeyIntSort(rv)</span>
}

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------

func KeyIntSort(in []int) (rv []int) <span class="cov0" title="0">{
        rv = in
        sort.Sort(sort.IntSlice(rv))
        return
}</span>

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------

//        lex .DumpTokenBuffer()
func (lex *Lexie) DumpTokenBuffer(fo io.Writer) <span class="cov0" title="0">{
        lex.TokList.FDumpTokenBuffer(fo, false)
}</span>
func (lex *Lexie) DumpTokenBuffer2(fo io.Writer) <span class="cov0" title="0">{
        lex.TokList.FDumpTokenBuffer(fo, true)
}</span>

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------

func (lex *Lexie) OutputActionFlags(dfa *DFA_PoolType) <span class="cov8" title="1">{
        com.DbPrintf("match", "Action Flags Are:\n")
        // com. ConvertActionFlagToString(kk int) (rv string) {
        dn := make(map[int]bool)
        for _, vv := range dfa.Pool </span><span class="cov8" title="1">{
                if vv.IsUsed </span><span class="cov8" title="1">{
                        if vv.Info.Action != 0 </span><span class="cov8" title="1">{
                                if _, ok := dn[vv.Info.Action]; !ok </span><span class="cov8" title="1">{
                                        com.DbPrintf("match", "    %2x: %s\n", vv.Info.Action, com.ConvertActionFlagToString(vv.Info.Action))
                                        dn[vv.Info.Action] = true
                                }</span>
                        }
                }
        }
}

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------

func NewContext(InitState int, dfa *DFA_PoolType) (rv *MatchContextType) <span class="cov8" title="1">{
        return &amp;MatchContextType{
                St:  InitState,
                Dfa: dfa,
        }
}</span>

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
func (lex *Lexie) InitGetToken(rrr *pbread.PBReadType, sm string) (AToken tok.Token) <span class="cov0" title="0">{
        lex.InputReader = rrr
        lex.StartMachine = sm
        // xyzzy
        return
}</span>

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
func (lex *Lexie) GetToken() (AToken tok.Token) <span class="cov0" title="0">{
        // xyzzy
        return
}</span>

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
func (lex *Lexie) FinializeMachines() <span class="cov8" title="1">{

        for ii := range lex.DFA_Machine </span><span class="cov8" title="1">{
                dfa := lex.DFA_Machine[ii]
                dfa.FinializeDFA()
        }</span>
}

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
func convRuleToActionFlag(ww *in.ImRuleType) int <span class="cov8" title="1">{
        rv := 0
        if ww.Repl </span><span class="cov8" title="1">{
                rv |= com.A_Repl
        }</span>
        <span class="cov8" title="1">if len(ww.CallName) &gt; 0 </span><span class="cov8" title="1">{
                rv |= com.A_Push
        }</span>
        <span class="cov8" title="1">if ww.Return </span><span class="cov8" title="1">{
                rv |= com.A_Pop
        }</span>
        <span class="cov8" title="1">if ww.Reset </span><span class="cov0" title="0">{
                rv |= com.A_Reset
        }</span>
        <span class="cov8" title="1">if ww.PatternType == 2 </span><span class="cov8" title="1">{
                rv |= com.A_EOF
        }</span>
        <span class="cov8" title="1">if ww.Err </span><span class="cov8" title="1">{
                rv |= com.A_Reset
                rv |= com.A_Error
        }</span>
        <span class="cov8" title="1">if ww.Warn </span><span class="cov8" title="1">{
                rv |= com.A_Warning
        }</span>
        <span class="cov8" title="1">if ww.NotGreedy </span><span class="cov8" title="1">{
                rv |= com.A_NotGreedy
        }</span>
        <span class="cov8" title="1">return rv</span>
}

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------

func (lex *Lexie) NewReadFile(path string) <span class="cov8" title="1">{
        lex.Im = in.ImReadFile(path)

        lex.NFA_Machine = make([]*nfa.NFA_PoolType, 0, 100)
        lex.DFA_Machine = make([]*DFA_PoolType, 0, 100)

        // vv=in.ImDefinedValueType {Seq:1 WhoAmI:ReservedWords NameValueStr:map[and:Tok_L_AND not:Tok_not as:Tok_as in:Tok_in bor:Tok_B_OR band:Tok_B_AND xor:Tok_XOR or:Tok_L_OR true:Tok_true false:Tok_false export:Tok_export] NameValue:map[and:4 true:32 as:34 bor:42 band:41 xor:64 or:5 false:33 not:31 export:35 in:28] Reverse:map[5:or 32:true 42:bor 31:not 41:band 35:export 33:false 28:in 64:xor 4:and 34:as] SeenAt:map[bor:{LineNo:[39] FileName:[unk-file]} band:{LineNo:[39] FileName:[unk-file]} and:{LineNo:[39] FileName:[unk-file]} true:{LineNo:[39] FileName:[unk-file]} export:{LineNo:[39] FileName:[unk-file]} in:{LineNo:[39] FileName:[unk-file]} as:{LineNo:[39] FileName:[unk-file]} or:{LineNo:[39] FileName:[unk-file]} false:{LineNo:[39] FileName:[unk-file]} not:{LineNo:[39 39] FileName:[unk-file unk-file]} xor:{LineNo:[39] FileName:[unk-file]}]}, File: /Users/corwin/Projects/pongo2/lexie/dfa/match.go LineNo:260
        for ii, vv := range lex.Im.Def.DefsAre </span><span class="cov8" title="1">{
                // ["ReservedWords"] {
                // func (st *SymbolTable) DefineReservedWord(name string, fxid int) (ss *SymbolType) {
                _ = ii
                _ = vv
                com.DbPrintf("dfa5", "vv=%T %+v, %s\n", vv, vv, com.LF())
        }</span>

        <span class="cov8" title="1">for ii, vv := range lex.Im.Machine </span><span class="cov8" title="1">{
                nm := vv.Name

                Nfa := nfa.NewNFA_Pool()
                Cur := Nfa.GetNFA()
                Nfa.InitState = Cur
                for jj, ww := range vv.Rules </span><span class="cov8" title="1">{
                        rVx := ww.Rv
                        if ww.ReservedWord </span><span class="cov8" title="1">{
                                com.DbPrintf("dfa5", "This rule rv=%d is a reserved word rule, AAbbCC\n", rVx)
                        }</span>
                        <span class="cov8" title="1">ww_A := convRuleToActionFlag(ww)
                        if ww.Repl </span><span class="cov8" title="1">{
                                rVx = 9900 // 9900 is replace
                                com.DbPrintf("match", "###################################### ww.Replace: ii=%d jj=%d -&gt;%s&lt;-, %s\n", ii, jj, ww.ReplString, com.LF())
                        }</span>
                        <span class="cov8" title="1">cur := -1
                        if ww.PatternType == 2 </span><span class="cov8" title="1">{
                                com.DbPrintf("db_Matcher_02", "ADDING AT %2d RE: %-30s (Rv:%2d, final=%4d), %s\n", jj, "&lt;M_EOF&gt;", ww.Rv, rVx, com.LF())
                                cur = Nfa.AddReInfo(re.X_EOF, "", jj+1, rVx, nfa.InfoType{Action: ww_A, NextState: ww.Call})
                        }</span><span class="cov8" title="1"> else {
                                com.DbPrintf("db_Matcher_02", "M= -&gt;%s&lt;- Adding at %2d RE: %-30s (Rv:%2d, final=%4d), %s\n", ww.Pattern, jj, ww.Pattern, ww.Rv, rVx, com.LF())
                                cur = Nfa.AddReInfo(ww.Pattern, "", jj+1, rVx, nfa.InfoType{Action: ww_A, NextState: ww.Call, ReplStr: ww.ReplString})
                        }</span>
                        <span class="cov8" title="1">if ww.ReservedWord </span><span class="cov8" title="1">{
                                Nfa.SetReservedWord(cur)
                        }</span>
                }

                <span class="cov8" title="1">com.DbPrintf("match", "BuildDFA_2: Nfa.Sigma Before Finialize-&gt;%s&lt;-\n", Nfa.Sigma)
                if com.DbOn("db_Matcher_02") </span><span class="cov8" title="1">{
                        com.DbPrintf("match", "NFA for (Before Finialize) -&gt;%s&lt;-\n", nm)
                        Nfa.DumpPool(false)
                }</span>

                <span class="cov8" title="1">Nfa.FinializeNFA()

                com.DbPrintf("match", "BuildDFA_2: Nfa.Sigma -&gt;%s&lt;-\n", Nfa.Sigma)
                if com.DbOn("db_Matcher_02") </span><span class="cov8" title="1">{
                        com.DbPrintf("match", "Final NFA for -&gt;%s&lt;-\n", nm)
                        Nfa.DumpPool(false)
                }</span>
                <span class="cov8" title="1">lex.NFA_Machine = append(lex.NFA_Machine, Nfa)

                Dfa := NewDFA_Pool()
                Dfa.ConvNDA_to_DFA(Nfa)
                if com.DbOn("db_Matcher_02") </span><span class="cov8" title="1">{
                        com.DbPrintf("match", "Final DFA for -&gt;%s&lt;-\n", nm)
                        Dfa.DumpPool(false)
                }</span>
                <span class="cov8" title="1">lex.DFA_Machine = append(lex.DFA_Machine, Dfa)

                if com.DbOn("db_Matcher_02") </span><span class="cov8" title="1">{

                        last := len(lex.DFA_Machine) - 1

                        newFile := fmt.Sprintf("../ref/mmm_%s_%d.tst", "machine", last)
                        gvFile := fmt.Sprintf("../ref/mmm_%s_%d.gv", "machine", last)
                        svgFile := fmt.Sprintf("../ref/mmm_%s_%d.svg", "machine", last)

                        fp, _ := filelib.Fopen(newFile, "w")
                        lex.DFA_Machine[last].DumpPoolJSON(fp, fmt.Sprintf("Lex-Machine-%d", last), 1)
                        fp.Close()

                        gv, _ := filelib.Fopen(gvFile, "w")
                        lex.DFA_Machine[last].GenerateGVFile(gv, fmt.Sprintf("Lex-Machine-%d", last), 1)
                        gv.Close()

                        out, err := exec.Command("/usr/local/bin/dot", "-Tsvg", "-o"+svgFile, gvFile).Output()
                        if err != nil </span><span class="cov8" title="1">{
                                com.DbPrintf("match", "%sError%s from dot, %s, %s\n", com.Red, com.Reset, err, com.LF())
                                com.DbPrintf("match", "Output: %s\n", out)
                        }</span>
                }
        }
}

/* vim: set noai ts=4 sw=4: */
</pre>
		
		<pre class="file" id="file2" style="display: none">//
// M A T C H - Part of Lexie Lexical Generation System
//
// (C) Philip Schlump, 2014-2015.
// Version: 1.0.8
// BuildNo: 203
//
// Special Thanks to 2C-Why, LLC for supporting this project.
//

/*
// ------------------------------------------------------------------------------------------------------------------------------------------------
// Plan
// ------------------------------------------------------------------------------------------------------------------------------------------------

+1. Study Django templates
        +2. Understand what they do
        +2. Decide on replace or use code
                http://www.b-list.org/weblog/2007/sep/22/standalone-django-scripts/

+0. What I want is to be able to get a lit of tokens/class/values out as an output from the CLI

+0. Use CLI and turn off all extraneous output -- Validate matches on a bunch of machines

0. Output machine as a .mlex format - machine lex format -m &lt;fn&gt;
0. Output machine as a .go format --fmt go -o &lt;fn&gt;
0. add "$cfg" to input - for config params like size of smap
0. add a SetConfig() to code to set the config params

+1. Use in Ringo
+2. The Pongo2 v.s. Ringo test
+3. Coverage Testing
4. Benchmarks
4. Memory usage - eliminate dynamic allocations
+4. Internal comments (doc.go) etc.
+5. As a "go-routine"



// ------------------------------------------------------------------------------------------------------------------------------------------------
//
// TODO:
//                1. Failure to match causes a fall-out-the-bottom and quit behavior - change to a reset to 0 and continue to EOF
//                                1. Warnings about bad tokens are not reported a {{ token should produce an error about invalid range.
//                                         1. xyzzyStackEmpty - if stack not empty then - pop and continue running on different data??a
//                1. In nfa-&gt;dfa conversion may end up with non-distinct terminal values - use one that is first seen? -- Lex implies this.
//                1. Rune Fix ( ../re/re.go:800 ) + test cases
//                                         xyzzyRune  TODO - this code is horribley non-utf8 compatable at this moment in time.
//
//        Err-Output:
//                        1. Tests in ../in/in.go - are not automated - fix to check results of input to be correct
//                                5. No test case for A_Reset
//                                7. No Test case for this error: --- CCL --- 0-0 is an invalid CCL, 1-0 also etc. -- Report
//
//        Feature
//                        1. Options on size of smap
//
// ------------------------------------------------------------------------------------------------------------------------------------------------
*/

package dfa

import (
        "os"

        "../com"
        "../pbread"
        "../re"
        "../tok"
)

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
type MatchContextType struct {
        St  int
        Dfa *DFA_PoolType
}

func (lex *Lexie) MatcherLexieTable(rrr *pbread.PBReadType, s_init string) <span class="cov8" title="1">{

        var dfa *DFA_PoolType
        var ii, to, pos_no, col_no, line_no int
        var rn rune
        var SMatch, filename string
        init := 0

        lex.FinializeMachines()

        init = lex.Im.LookupMachine(s_init)
        for ii := range lex.DFA_Machine </span><span class="cov8" title="1">{
                com.DbPrintf("match", "Machine[%d] =\n", ii)
                dfa = lex.DFA_Machine[ii]
                dfa.MachineId = ii
                dfa.OutputInFormat(os.Stdout, "text")

                lex.OutputActionFlags(dfa)
        }</span>
        <span class="cov8" title="1">dfa = lex.DFA_Machine[init]

        ctx := NewContext(dfa.MTab.InitState, nil)
        ctx_stack := make([]*MatchContextType, 0, 100)

        lex.TokList = tok.NewTokenList()
        ignoreToken := lex.Im.Lookup("Tokens", "Tok_Ignore")
        aTok_EOF := lex.Im.Lookup("Tokens", "Tok_EOF")
        lex.TokList.IgnoreToken = ignoreToken
        line_no = 1
        col_no = 1
        pos_no = 1
        filename = ""
        SMatch = ""
        AtEOF := false
        done := false
        TokStart := 0

        Next := func() (rn rune) </span><span class="cov8" title="1">{
                rn, done := rrr.NextRune()
                if done </span><span class="cov0" title="0">{
                        AtEOF = true
                        rn = re.R_EOF
                        return
                }</span><span class="cov8" title="1"> else {
                        SMatch += string(rn)
                        pos_no++
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">Peek := func() (rn rune) </span><span class="cov8" title="1">{
                rn, done = rrr.PeekRune()
                if done </span><span class="cov8" title="1">{
                        AtEOF = true
                        rn = re.R_EOF
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">var p_line_no int = 1
        var p_col_no int = 1
        SaveToken := func() </span><span class="cov8" title="1">{
                start := pos_no - dfa.MTab.Machine[ctx.St].Info.MatchLength
                if dfa.MTab.Machine[ctx.St].Info.MatchLength == 0 </span><span class="cov8" title="1">{
                        start = 0
                }</span>
                <span class="cov8" title="1">line_no, col_no, filename = rrr.GetPos()
                if col_no &gt; dfa.MTab.Machine[ctx.St].Info.MatchLength </span><span class="cov8" title="1">{
                        col_no -= dfa.MTab.Machine[ctx.St].Info.MatchLength
                }</span>

                <span class="cov8" title="1">lRv := dfa.MTab.Machine[ctx.St].Rv

                // xyzzy - this is the spot to convert from Tok_ID &amp;&amp; ReservedWord -&gt; a new ID
                // lex.Im.St.Lookup.LookupSymbol(SMatch)
                // func (st *SymbolTable) LookupSymbol(name string) (as *SymbolType, err error) {
                // vv=in.ImDefinedValueType {Seq:1 WhoAmI:ReservedWords NameValueStr:map[and:Tok_L_AND not:Tok_not as:Tok_as in:Tok_in bor:Tok_B_OR band:Tok_B_AND xor:Tok_XOR or:Tok_L_OR true:Tok_true false:Tok_false export:Tok_export] NameValue:map[and:4 true:32 as:34 bor:42 band:41 xor:64 or:5 false:33 not:31 export:35 in:28] Reverse:map[5:or 32:true 42:bor 31:not 41:band 35:export 33:false 28:in 64:xor 4:and 34:as] SeenAt:map[bor:{LineNo:[39] FileName:[unk-file]} band:{LineNo:[39] FileName:[unk-file]} and:{LineNo:[39] FileName:[unk-file]} true:{LineNo:[39] FileName:[unk-file]} export:{LineNo:[39] FileName:[unk-file]} in:{LineNo:[39] FileName:[unk-file]} as:{LineNo:[39] FileName:[unk-file]} or:{LineNo:[39] FileName:[unk-file]} false:{LineNo:[39] FileName:[unk-file]} not:{LineNo:[39 39] FileName:[unk-file unk-file]} xor:{LineNo:[39] FileName:[unk-file]}]}, File: /Users/corwin/Projects/pongo2/lexie/dfa/match.go LineNo:260
                if dfa.MTab.Machine[ctx.St].Info.ReservedWord </span><span class="cov8" title="1">{
                        com.DbPrintf("match4", "\n\nFound a  reserved word ------------------------------------------------------------------------ CCddEE, %s\n", com.LF())
                        com.DbPrintf("match4", "SMatch &gt;%s&lt;, %s\n", SMatch, com.LF())

                        vv, ok := lex.Im.Def.DefsAre["ReservedWords"].NameValue[SMatch]
                        if ok </span><span class="cov8" title="1">{
                                com.DbPrintf("match4", "Substituting(2) -- xyzzy hard coded for test --- Found it as %d !!!, %s\n", vv, com.LF())
                                lRv = vv
                        }</span>

                        <span class="cov8" title="1">com.DbPrintf("match4", "\n\n")</span>
                }

                <span class="cov8" title="1">com.DbPrintf("match", "+==================================================================================\n")
                com.DbPrintf("match", "+ SaveToken: Line:%d Col:%d\n", line_no, col_no)
                com.DbPrintf("match", "+==================================================================================\n")
                lex.TokList.AddTokenToBuffer(tok.Token{
                        Match:    SMatch,
                        Val:      SMatch,
                        LineNo:   p_line_no,
                        ColNo:    p_col_no,
                        FileName: filename,
                        TokNo:    lRv,
                }, start, pos_no, 1)
                p_line_no = line_no
                p_col_no = col_no</span>
        }

        <span class="cov8" title="1">FlushToken := func(isHard bool) </span><span class="cov8" title="1">{
                if dfa.MTab.Machine[ctx.St].Rv == 9900 &amp;&amp; (com.A_Repl&amp;dfa.MTab.Machine[ctx.St].Info.Action) != 0 </span><span class="cov0" title="0">{
                        com.DbPrintf("match", " Doing Replace on Token, Len %d to -&gt;%s&lt;-\n ", dfa.MTab.Machine[ctx.St].Info.MatchLength, dfa.MTab.Machine[ctx.St].Info.ReplStr)
                        lex.TokList.ReplaceToken(dfa.MTab.Machine[ctx.St].Info.MatchLength, dfa.MTab.Machine[ctx.St].Info.ReplStr)
                }</span>
                <span class="cov8" title="1">com.DbPrintf("match4", "FlushTokenStareted ------------------------------------------------------------------------------\n")
                beforeFlush := len(lex.TokList.TokenData)
                lex.TokList.FlushTokenBuffer(TokStart, isHard, AtEOF)
                afterFlush := len(lex.TokList.TokenData)

                if lex.SendOnChanel </span><span class="cov0" title="0">{
                        for ll := beforeFlush; ll &lt; afterFlush; ll++ </span><span class="cov0" title="0">{

                                tt := LexieChanelType{Token: lex.TokList.TokenData[ll]}
                                lex.Message &lt;- tt
                        }</span>
                }
                <span class="cov8" title="1">TokStart = 0
                SMatch = ""
                com.DbPrintf("match4", "FlushTokenEnded ------------------------------------------------------------------------------\n")</span>
        }

        <span class="cov8" title="1">DumpStack := func() </span><span class="cov8" title="1">{
                com.DbPrintf("match4", "\tDump ctx_stack len=[%d]\n", len(ctx_stack))
                for ii := range ctx_stack </span><span class="cov8" title="1">{
                        com.DbPrintf("match4", "\t\tDump ctx_stack[%d] = machine %d\n", ii, ctx_stack[ii].Dfa.MachineId)
                }</span>
        }

        <span class="cov8" title="1">PushState := func(St int) </span><span class="cov8" title="1">{
                com.DbPrintf("match", "\n-------------------------------------------------------------------------------\n")
                com.DbPrintf("match", "Found a PUSH: to %d -- This should be subscript of new machine\n", dfa.MTab.Machine[St].Info.NextState)
                com.DbPrintf("match", "-------------------------------------------------------------------------------\n")
                t_ctx := NewContext(0, dfa)

                ns := dfa.MTab.Machine[St].Info.NextState
                ctx_stack = append(ctx_stack, t_ctx)
                DumpStack()

                ctx.St = 0
                dfa = lex.DFA_Machine[ns]
        }</span>

        <span class="cov8" title="1">PopState := func() </span><span class="cov8" title="1">{
                if len(ctx_stack) &gt;= 1 </span><span class="cov8" title="1">{
                        t_ctx := ctx_stack[len(ctx_stack)-1]
                        ctx_stack = ctx_stack[0 : len(ctx_stack)-1]
                        dfa = t_ctx.Dfa
                        com.DbPrintf("match", "\n-------------------------------------------------------------------------------\n")
                        com.DbPrintf("match", "Found a POP: State Poping like Corn, Machine now %d\n", dfa.MachineId)
                        com.DbPrintf("match", "-------------------------------------------------------------------------------\n")
                        DumpStack()
                }</span><span class="cov0" title="0"> else {
                        com.DbPrintf("match", "Error: Attempt to pop when stack is empty\n")
                }</span>
                <span class="cov8" title="1">ctx.St = 0</span>
        }

        <span class="cov8" title="1">ResetState := func() </span><span class="cov0" title="0">{
                com.DbPrintf("match", "Found a RESET\n")
                ctx_stack = ctx_stack[:0]
                dfa = lex.DFA_Machine[init]
                ctx.St = 0
        }</span>

        <span class="cov8" title="1">for !done </span><span class="cov8" title="1">{
                com.DbPrintf("match", "\n**********************************************************************************************************\n")
                com.DbPrintf("match", "Top: (machine number %d) ctx.St:%d\n", dfa.MachineId, ctx.St)
                cur_st := ctx.St

                rn = Peek()
                ii = dfa.MTab.SMap.MapRune(rn)
                to = dfa.MTab.Machine[cur_st].To[ii]
                hh := dfa.MTab.Machine[cur_st].Info.HardMatch
                com.DbPrintf("match", " (peek) machine=%d cur_st=%d ii=%d for rune rn=-&gt;%s&lt;- to=%d hard=%v Rv=%d Tau=%v\n",
                        dfa.MachineId, cur_st, ii, string(rn), to, hh, dfa.MTab.Machine[cur_st].Rv, dfa.MTab.Machine[cur_st].Tau)
                if rn == re.R_EOF </span><span class="cov8" title="1">{
                        com.DbPrintf("match", " At: %s\n", com.LF())
                        FlushToken(true)
                }</span><span class="cov8" title="1"> else if dfa.MTab.Machine[cur_st].Rv &gt; 0 &amp;&amp; dfa.MTab.Machine[cur_st].Tau &amp;&amp; to == -1 </span><span class="cov8" title="1">{
                        com.DbPrintf("match", " At: %s\n", com.LF())
                        SaveToken()
                        FlushToken(hh)
                }</span><span class="cov8" title="1"> else if dfa.MTab.Machine[cur_st].Rv &gt; 0 &amp;&amp; hh </span><span class="cov8" title="1">{
                        if to == -1 </span><span class="cov8" title="1">{
                                com.DbPrintf("match", " At: %s\n", com.LF())
                                SaveToken()
                                FlushToken(hh)
                        }</span><span class="cov8" title="1"> else {
                                com.DbPrintf("match", " At: %s\n", com.LF())
                                // (peek) machine=0 cur_st=3 ii=5 for rune rn=-&gt; &lt;- to=0 hard=true Rv=8 Tau=true
                                if (com.A_Push &amp; dfa.MTab.Machine[cur_st].Info.Action) == 0 </span><span class="cov8" title="1">{
                                        com.DbPrintf("match", " At: %s\n", com.LF())
                                        rn = Next() // Remove makes beginning work
                                }</span>
                                <span class="cov8" title="1">SaveToken()</span>
                        }
                        <span class="cov8" title="1">ctx.St = to</span>
                }<span class="cov8" title="1"> else if dfa.MTab.Machine[cur_st].Rv &gt; 0 </span><span class="cov8" title="1">{ // &amp;&amp; !dfa.MTab.Machine[cur_st].Tau &amp;&amp; to != -1 {
                        com.DbPrintf("match", " At: %s\n", com.LF())
                        rn = Next()
                        SaveToken()
                        ctx.St = to
                }</span><span class="cov8" title="1"> else if ((com.A_Push | com.A_Pop | com.A_Reset) &amp; dfa.MTab.Machine[cur_st].Info.Action) != 0 </span><span class="cov8" title="1">{
                        com.DbPrintf("match", "-- critical -- At: %s\n", com.LF())
                        // (peek) machine=2 cur_st=21 ii=24 for rune rn=-&gt;{&lt;- to=36 hard=false Rv=0 Tau=false
                        // (peek) machine=2 cur_st=24 ii=4 for rune rn=-&gt; &lt;- to=-1 hard=true Rv=0 Tau=false
                        if to &gt;= 0 </span><span class="cov0" title="0">{
                                rn = Next()
                        }</span>
                        <span class="cov8" title="1">ctx.St = to</span>
                }<span class="cov0" title="0"> else {
                        com.DbPrintf("match", "-- other --  At: %s\n", com.LF())
                        if to &gt;= 0 </span><span class="cov0" title="0">{
                                rn = Next()
                        }</span>
                        <span class="cov0" title="0">ctx.St = to</span>
                }

                <span class="cov8" title="1">if (com.A_Push &amp; dfa.MTab.Machine[cur_st].Info.Action) != 0 </span><span class="cov8" title="1">{ //                                         xyzzy - total bullshit -- Allows to hapen on non-termaial in middle of stuff -- call non-terminal
                        com.DbPrintf("match", "PUSH: At: %s\n", com.LF())
                        PushState(cur_st)
                }</span><span class="cov8" title="1"> else if (com.A_Pop&amp;dfa.MTab.Machine[cur_st].Info.Action) != 0 &amp;&amp; to == -1 </span><span class="cov8" title="1">{ //         xyzzy - total bullshit -- Only on terminal state!
                        com.DbPrintf("match", "POP: cur_st=%d Rv=%d At: %s\n", cur_st, dfa.MTab.Machine[cur_st].Rv, com.LF())
                        PopState()
                }</span><span class="cov8" title="1"> else if (com.A_Reset &amp; dfa.MTab.Machine[cur_st].Info.Action) != 0 </span><span class="cov0" title="0">{
                        com.DbPrintf("match", "RESET: At: %s\n", com.LF())
                        ResetState()
                }</span>

                <span class="cov8" title="1">com.DbPrintf("match4", "Match, continuing to advance[ctx.St=%d] rn=%s", ctx.St, string(rn))
                com.DbPrintf("match4", " ii=%d to=%d\n", ii, to)
                if to == -1 </span><span class="cov8" title="1">{
                        com.DbPrintf("match", "to=-1, At: %s\n", com.LF())
                        ctx.St = 0
                }</span>
                <span class="cov8" title="1">if rn == re.R_EOF </span><span class="cov8" title="1">{
                        com.DbPrintf("match", " At: %s\n", com.LF())
                        done = true
                }</span>

        }
        <span class="cov8" title="1">if AtEOF </span><span class="cov8" title="1">{
                com.DbPrintf("match", " Reached EOF\n")
        }</span><span class="cov0" title="0"> else {
                com.DbPrintf("match", " Early Exit!!!, no match!!!\n")
        }</span>

        <span class="cov8" title="1">if lex.SendOnChanel </span><span class="cov0" title="0">{
                tt := LexieChanelType{Token: tok.Token{TokNo: aTok_EOF}}
                lex.Message &lt;- tt
                //pjs July 3 - close(lex.Message)
        }</span>

}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
